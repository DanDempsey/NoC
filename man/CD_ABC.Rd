% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CD_ABC.R
\name{CD_ABC}
\alias{CD_ABC}
\title{Estimate Number of Classes via ABC}
\usage{
CD_ABC(
  iters,
  x,
  t,
  theta_N,
  theta_x,
  theta_l,
  m = 10,
  metric = "minkowski",
  p = 2,
  epsilon = -1,
  x_weight = 1,
  t_weight = 1,
  abundance_hyperprior = FALSE,
  cores = 1
)
}
\arguments{
\item{iters}{The number of iterations for the ABC algorithm.}

\item{x}{Numeric vector corresponding the effort proxy.}

\item{t}{Numeric vector corresponding the discovery times. Must be the same length as x.}

\item{theta_N}{A numeric vector of length two if abundance_hyperprior = FALSE and length three otherwise. The first component always corresponds to the mean of the species abundance prior. If abundance_hyperpior = FALSE, the second component is the variance; if abundance_hyperprior = TRUE, then the second and third components correspond to the bounds of the uniform hyperprior for the abundance variance.}

\item{theta_x}{A single numeric. Corresponds to the log difference in the mean of the effort proxy and the latent effort process.}

\item{theta_l}{A numeric vector of length 2. The first component is the starting position of the latent effort process, and the second component is the variance parameter of the IGMRF that the latent effort is assumed to follow.}

\item{m}{A single numeric. Multiple of the upper boundary of the prior for C.}

\item{metric}{Either "minkowski" or "canberra", corresponding to the distance metric. Partial matching is supported.}

\item{p}{The order of the minkowski distance. p = 1 corresponds to the Manhattan distance, 2 corresponds to the Euclidean distance. Unused if metric = "canberra".}

\item{epsilon}{The distance threshold for acceptance. If set to a negative number, then treated as infinity.}

\item{x_weight}{The weight applied to the distance component corresponding to the effort proxy.}

\item{t_weight}{The weight applied to the distance component corresponding to the discovery times.}

\item{abundance_hyperprior}{A logical that indicates if the user wants to use a uniform hyperprior for the abundance prior variance parameter.}

\item{cores}{This function supports parallelisation. This parameter sets the number of cores the number wants to utilise.}
}
\value{
A list containing the approximate posterior draws for the number of classes (denoted 'C'), the value of the corresponding distance metric, and the corresponding simulations of the effort proxy and discovery times.
}
\description{
Fits a generative model for class discovery via ABC to approximate a posterior for the total number of classes.
}
\details{
This function fits a generative model of class discovery via Approximate Bayesian Computation (ABC), for the purpose of estimating the total number of classes that exist overall. For example, the number of species of a type of animal. The model requires data inputs x (a numeric proxy of the amount of effort per year) and t (the number of discoveries per year). It also requires prior specification on the abundance of each species (assumed lognormally distributed), the latent effort process (assumed to be an intrinsic Gaussian random process) and mean difference between the observed effort proxy and the latent effort process on the log scale. The ABC algorithm simulates x and t every iteration and measures the distance between these simulations and the observed value of x and t. If the distance is within a given threshold, that iteration (and accompyaning value of the total number of classes) is accecpted as a draw from a distribution that approximates the posterior distribution of the number of classes.
}
\examples{
data( Aves )
set.seed( 100 )
pilot_run <- CD_ABC( 1e3, x = Aves$Effort_Proxy, t = Aves$Discovery_Times,
                     theta_N = c(log(1e9), 1.1), theta_x = log(2),
                     theta_l = c(log(30), 0.08), m = 20 )

thresh <- quantile( pilot_run$distance, 0.1 )

actual_run <- CD_ABC( 1e4, x = Aves$Effort_Proxy, t = Aves$Discovery_Times,
                      theta_N = c(log(1e9), 1.1), theta_x = log(2),
                      theta_l = c(log(30), 0.08), m = 20, epsilon = thresh )

plot( density(actual_run$C), type = 'l' )
}
